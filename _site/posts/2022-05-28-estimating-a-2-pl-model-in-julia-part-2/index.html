<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.433">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Mark Lai">
<meta name="dcterms.date" content="2022-05-28">

<title>Mark Lai - Estimating a 2-PL Model in Julia (Part 2)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NLMBWPMFDG"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-NLMBWPMFDG', { 'anonymize_ip': true});
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Mark Lai</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../post.html" rel="" target="">
 <span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publication.html" rel="" target="">
 <span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../software.html" rel="" target="">
 <span class="menu-text">Software</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../course.html" rel="" target="">
 <span class="menu-text">Courses</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../presentation.html" rel="" target="">
 <span class="menu-text">Presentations</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#e-step" id="toc-e-step" class="nav-link active" data-scroll-target="#e-step">E-Step</a></li>
  <li><a href="#m-step" id="toc-m-step" class="nav-link" data-scroll-target="#m-step">M-Step</a></li>
  <li><a href="#estimating-a-2-pl-model-with-em-in-julia" id="toc-estimating-a-2-pl-model-with-em-in-julia" class="nav-link" data-scroll-target="#estimating-a-2-pl-model-with-em-in-julia">Estimating a 2-PL Model with EM in Julia</a>
  <ul class="collapse">
  <li><a href="#find-bar-r_jk-and-bar-n_k" id="toc-find-bar-r_jk-and-bar-n_k" class="nav-link" data-scroll-target="#find-bar-r_jk-and-bar-n_k">Find <span class="math inline">\(\bar r_{jk}\)</span> and <span class="math inline">\(\bar n_k\)</span></a></li>
  <li><a href="#solve-estimating-equations" id="toc-solve-estimating-equations" class="nav-link" data-scroll-target="#solve-estimating-equations">Solve estimating equations</a></li>
  <li><a href="#iterations" id="toc-iterations" class="nav-link" data-scroll-target="#iterations">Iterations</a></li>
  <li><a href="#stopping-criteria" id="toc-stopping-criteria" class="nav-link" data-scroll-target="#stopping-criteria">Stopping criteria</a></li>
  </ul></li>
  <li><a href="#benchmarking" id="toc-benchmarking" class="nav-link" data-scroll-target="#benchmarking">Benchmarking</a></li>
  <li><a href="#remark" id="toc-remark" class="nav-link" data-scroll-target="#remark">Remark</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Estimating a 2-PL Model in Julia (Part 2)</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Statistics</div>
    <div class="quarto-category">Programming</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Mark Lai </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">May 28, 2022</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<div class="hidden">
<p><span class="math display">\[
  \newcommand{\bv}[1]{\boldsymbol{\mathbf{#1}}}
\]</span></p>
</div>
<p>The EM algorithm is usually used for estimation problems that involve some latent variables <span class="math inline">\(\bv Z\)</span> and parameters <span class="math inline">\(\bv \omega\)</span>, where the conditional likelihood <span class="math inline">\(L(\bv \omega; \bv Y, \bv Z)\)</span> is relatively easy to solve, but the marginal likelihood, which requires integrating <span class="math inline">\(\bv Z\)</span> out, is intractable. In the 2-PL estimation problem, we consider the item parameters <span class="math inline">\(\bv a\)</span> and <span class="math inline">\(\bv d\)</span> as <span class="math inline">\(\bv \omega\)</span>, and the person parameters <span class="math inline">\(\bv \theta\)</span> as <span class="math inline">\(\bv Z\)</span>.</p>
<p>In a general IRT model, the marginal likelihood function <span class="math inline">\(L(\bv \omega; \bv Y)\)</span> requires integrating out the person parameters <span class="math inline">\(\bv \theta\)</span>, which is usually difficult. We can instead use the EM algorithm. First, we can define the complete-data likelihood</p>
<p><span class="math display">\[L(\bv \omega; \bv Y, \bv \theta) = P(\bv Y \mid \bv \theta, \bv \omega) P(\bv \theta \mid \bv \omega)\]</span></p>
<p>assuming that observations are independently and identically distributed given <span class="math inline">\(\bv \theta\)</span>, and <strong>local independence</strong> such that the item responses are independent when conditioning on <span class="math inline">\(\bv \theta\)</span>, we have</p>
<p><span class="math display">\[L(\bv \omega; \bv Y, \bv \theta) = \prod_i^N \prod_j L_{ij} P(\theta_i \mid \bv \omega_j)\]</span></p>
<p>where <span class="math inline">\(L_{ij} = P(y_{ij} \mid \theta_i, \bv \omega_j)\)</span>. Thus, the complete-data <em>loglikelihood</em> is</p>
<p><span class="math display">\[\ell(\bv \omega; \bv Y, \bv \theta) = \log L(\bv \omega; \bv Y, \bv \theta) = \sum_i^N \sum_j \left[\ell_{ij} + \log P(\theta_i \mid \bv \omega_j)\right],\]</span></p>
<p>where <span class="math inline">\(\ell_{ij} = \log L_{ij}\)</span></p>
<p>With the <a href="https://en.wikipedia.org/wiki/Expectation%E2%80%93maximization_algorithm">EM algorithm</a>, we update our parameter estimates by iterating between two steps:</p>
<ul>
<li>E-step: obtain <span class="math inline">\(E_{\bv \theta \mid \bv Y, \bv \omega^{(t)}}[\ell(\bv \omega; \bv Y, \bv \theta)]\)</span> with respect to the conditional distribution <span class="math inline">\(\bv \theta \mid \bv Y, \bv \omega^{(t)}\)</span>, treating <span class="math inline">\(\bv \omega^{(t)}\)</span> as known;</li>
<li>M-step: obtain new <span class="math inline">\(\bv \omega^{(t + 1)}\)</span> that maximizes <span class="math inline">\(E_{\bv \theta \mid \bv Y, \bv \omega^{(t)}}[\ell(\bv \omega; \bv Y, \bv \theta)]\)</span>.</li>
</ul>
<p>Note: the setup of the problem in this post deviates a bit from the one in the original <a href="https://link.springer.com/article/10.1007/BF02293801">Bock and Aitkin paper</a>, which assumes a multinomial distribution of the sample counts of each response pattern. The resulting estimating equations should be the same.</p>
<section id="e-step" class="level2">
<h2 class="anchored" data-anchor-id="e-step">E-Step</h2>
<p>First consider the E-step for the 2-PL model, which has</p>
<p><span class="math display">\[
  \begin{aligned}
    \ell_{ij} &amp; = y_{ij} \log \eta_{ij} - \log[1 + \exp(\eta_{ij})] \\
    \eta_{ij} &amp; = a_j \theta_i + d_j
  \end{aligned}.
\]</span></p>
<p>In addition, in IRT, because item responses are discrete, the <span class="math inline">\(N\)</span> observations can usually be reduced to a smaller number of <span class="math inline">\(l\)</span> response patterns. For example, with the <code>LSAT</code> data, which has 1,000 observations, it only has 30 response patterns of 5 binary items:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">RCall</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>lsat <span class="op">=</span> <span class="fu">rcopy</span>(R<span class="st">"mirt::LSAT6"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>30×6 DataFrame
 Row │ Item_1  Item_2  Item_3  Item_4  Item_5  Freq
     │ Int64   Int64   Int64   Int64   Int64   Int64
─────┼───────────────────────────────────────────────
   1 │      0       0       0       0       0      3
   2 │      0       0       0       0       1      6
   3 │      0       0       0       1       0      2
   4 │      0       0       0       1       1     11
   5 │      0       0       1       0       0      1
   6 │      0       0       1       0       1      1
   7 │      0       0       1       1       0      3
   8 │      0       0       1       1       1      4
  ⋮  │   ⋮       ⋮       ⋮       ⋮       ⋮       ⋮
  24 │      1       1       0       0       1     56
  25 │      1       1       0       1       0     21
  26 │      1       1       0       1       1    173
  27 │      1       1       1       0       0     11
  28 │      1       1       1       0       1     61
  29 │      1       1       1       1       0     28
  30 │      1       1       1       1       1    298
                                      15 rows omitted</code></pre>
<p>So instead of computing the loglikelihood for 1,000 observations, we only need to do it for <span class="math inline">\(s = 30\)</span> response patterns. So the complete-data loglikelihood can be written as</p>
<p><span class="math display">\[\ell(\bv \omega; \bv Y, \bv \theta) = \sum_{l = 1}^s \sum_j n_l \ell_{lj} + \sum_{i = 1}^n \sum_j \log P(\theta_i \mid \bv \omega_j),\]</span></p>
<p>with <span class="math inline">\(\ell_{lj} = \log L_{lj} = \log P(y_{lj} \mid \bv \omega_j, \theta)\)</span> for a fixed <span class="math inline">\(\theta\)</span> value.</p>
<p>For the E-step, we first need the conditional distribution <span class="math inline">\(P(\theta \mid \bv Y, \bv a^{(t)}, \bv d^{(t)})\)</span> with some fixed values of <span class="math inline">\(\bv a^{(t)}\)</span> and <span class="math inline">\(\bv d^{(t)}\)</span>, which can be obtained with Bayes’ theorem</p>
<p><span class="math display">\[P(\theta_i \mid \bv y_l, \bv a^{(t)}, \bv d^{(t)}) = \frac{P(\bv y_l \mid \theta_i, \bv a^{(t)}, \bv d^{(t)})P(\theta_i)}{\int P(\bv y_l \mid \theta, \bv a^{(t)} \bv d^{(t)})P(\theta) d\theta}\]</span></p>
<p>We need a prior distribution <span class="math inline">\(P(\theta)\)</span>, which is commonly chosen as a normal distribution (and standard normal for single group analysis). Using Gaussian-Hermite (GH) quadrature to replace <span class="math inline">\(P(\theta_k)\)</span> by <span class="math inline">\(w_k\)</span>, where <span class="math inline">\(k\)</span> being one of the <span class="math inline">\(q\)</span> quadrature points, and replacing the intergral with the finite sum, we have:</p>
<p><span class="math display">\[
  \begin{aligned}
  P(\theta_k \mid \bv y_l, \bv a^{(t)}, \bv d^{(t)}) &amp; \approx \frac{P(\bv y_l \mid \theta_i, \bv a, \bv d) w_k}{\sum_{k = 1}^q P(\bv y_l \mid \theta, \bv a \bv d) w_k} \\
  &amp; = \frac{L^{(t)}_l(\theta_k)w_k}{\sum_k L^{(t)}_l(\theta_k) w_k} \\
  &amp; = \frac{L^{(t)}_l(\theta_k)w_k}{P_l}
  \end{aligned}
\]</span></p>
<p>Note the subscript <span class="math inline">\((t)\)</span> indicating that <span class="math inline">\(L^{(t)}_l(\cdot)\)</span> is a function of <span class="math inline">\(\theta\)</span> with fixed values of the item parameters. Now we can taking the expectation of the complete-data loglikelihood with respect to the conditional distribution we just saw:</p>
<p><span class="math display">\[
  \begin{aligned}
  E_{\bv \theta \mid \bv Y, \bv \omega^{(t)}}[\ell(\bv \omega; \bv Y, \bv \theta)]
  &amp; = E_{\bv \theta \mid \bv Y, \bv \omega^{(t)}}\left[\sum_l \sum_j n_l \ell_{lj} \right] \\
  &amp; \quad + E_{\bv \theta \mid \bv Y, \bv \omega^{(t)}} \left[\sum_l \sum_j \log P(\theta_i \mid \bv \omega^{(t)})\right],
  \end{aligned}
\]</span></p>
<p>Note that the second expectation term is not a function of the item parameters (it is a function of <span class="math inline">\(\theta\)</span> treating the item parameters as fixed), so we can write it as <span class="math inline">\(h(\bv \theta)\)</span>, which is a constant for the maximization step. So using G-H quadrature to approximate the integral when taking the expectation, we have</p>
<p><span class="math display">\[
  \begin{aligned}
  E_{\bv \theta \mid \bv Y, \bv \omega^{(t)}}[\ell(\bv \omega; \bv Y, \bv \theta)]
  &amp; = \int \left[\sum_l \sum_j n_l \ell_{lj} P(\theta \mid \bv y_l, \bv \omega^{(t)})\right] d \theta + h(\bv \theta) \\
  &amp; = \sum_k \sum_l \sum_j \frac{ n_l \ell_{lj} L^{(t)}_l(\theta_k)w_k}{P_l} + h(\bv \theta)
  \end{aligned}
\]</span></p>
</section>
<section id="m-step" class="level2">
<h2 class="anchored" data-anchor-id="m-step">M-Step</h2>
<p>In the M-step, we find new values <span class="math inline">\(\bv \omega^{(t + 1)}\)</span> that maximize the expected loglikelihood above. To find the maximizer, we take the derivative of the expected loglikelihood with respect to each parameter, and set the derivative to zero. This gives us a set of <em>estimating equations</em>. First, it can be verified that</p>
<p><span class="math display">\[
  \begin{aligned}
    \frac{\partial \ell_{lj}}{\partial a_j} &amp; = \left[y_{lj} - P_j(\theta_k)\right] \theta_k \\
    \frac{\partial \ell_{lj}}{\partial d_j} &amp; = y_{lj} - P_j(\theta_k),
  \end{aligned}
\]</span></p>
<p>where <span class="math inline">\(P_j(\theta_k) = \eta_{kj} / (1 + \eta_{kj})\)</span>. So the derivative of the expected loglikelihood with respect to <span class="math inline">\(a_j\)</span> is</p>
<p><span class="math display">\[
  \begin{aligned}
  \frac{\partial}{\partial a_j} E_{\bv \theta \mid \bv Y, \bv \omega^{(t)}}[\ell(\bv \omega; \bv Y, \bv \theta)]
  &amp; = \sum_k \sum_l \frac{n_l [y_{lj} - P_j(\theta_k)] \theta_k L^{(t)}_l(\theta_k)w_k}{P_l}.
  \end{aligned}
\]</span></p>
<p>Following the previous literature, let</p>
<p><span class="math display">\[
  \begin{aligned}
  \bar r_{jk} &amp; = \sum_l \frac{n_l y_{lj} L^{(t)}_l(\theta_k)w_k}{P_l} \\
  \bar n_k &amp; = \sum_l \frac{n_l L^{(t)}_l(\theta_k)w_k}{P_l},
  \end{aligned}
\]</span></p>
<p>where <span class="math inline">\(n_k\)</span> is the expected number of participants with ability level <span class="math inline">\(\theta_k\)</span>, and <span class="math inline">\(r_{jk}\)</span> is the expected number of participants with ability level <span class="math inline">\(\theta_k\)</span> endorsing item <span class="math inline">\(j\)</span>. Then the estimating equations are</p>
<p><span class="math display">\[
  \begin{aligned}
  \sum_k [\bar r_{jk} - \bar n_k P_j(\theta_k)] = 0 \\
  \sum_k [\bar r_{jk} - \bar n_k P_j(\theta_k)] \theta_k = 0
  \end{aligned}
\]</span></p>
<p>for <span class="math inline">\(j = 1, \ldots, p\)</span> where <span class="math inline">\(p\)</span> is the number of items. These can be solved using non-linear solvers.</p>
</section>
<section id="estimating-a-2-pl-model-with-em-in-julia" class="level2">
<h2 class="anchored" data-anchor-id="estimating-a-2-pl-model-with-em-in-julia">Estimating a 2-PL Model with EM in Julia</h2>
<p>Here is my attempt to implement the EM algorithm in Julia, following the steps laid out in Harwell (1988). First, load the packages</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">LinearAlgebra</span>, <span class="bu">LogExpFunctions</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">FastGaussQuadrature</span>: gausshermite</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">NLsolve</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">BenchmarkTools</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="find-bar-r_jk-and-bar-n_k" class="level3">
<h3 class="anchored" data-anchor-id="find-bar-r_jk-and-bar-n_k">Find <span class="math inline">\(\bar r_{jk}\)</span> and <span class="math inline">\(\bar n_k\)</span></h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Helper for computing logits: ηᵢⱼ = aⱼθ + dⱼ</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">compute_logits</span>(θ, a, d)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    [θ[i] <span class="op">*</span> a[j] <span class="op">+</span> d[j]</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>     for i <span class="op">=</span> <span class="fu">eachindex</span>(θ), j <span class="op">=</span> <span class="fu">eachindex</span>(a)]</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>compute_logits (generic function with 1 method)</code></pre>
<div class="sourceCode" id="cb6"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">eloglik_2pl_em</span>(y, n, θ, w, parₜ)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    num_items <span class="op">=</span> <span class="fu">size</span>(y, <span class="fl">2</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    aₜ <span class="op">=</span> parₜ[<span class="fl">1</span><span class="op">:</span>num_items]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    dₜ <span class="op">=</span> parₜ[num_items<span class="op">+</span><span class="fl">1</span><span class="op">:</span><span class="kw">end</span>]</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    ηₜ <span class="op">=</span> <span class="fu">compute_logits</span>(θ, aₜ, dₜ)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    sum1pexpη <span class="op">=</span> <span class="fu">sum</span>(log1pexp, ηₜ, dims<span class="op">=</span><span class="fl">2</span>)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    wpy_given_θ <span class="op">=</span> <span class="fu">Matrix</span><span class="dt">{eltype(aₜ)}</span>(<span class="cn">undef</span>, <span class="fu">length</span>(θ), <span class="fu">length</span>(n))</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> l <span class="kw">in</span> <span class="fu">eachindex</span>(n)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        wpy_given_θ[<span class="op">:</span>, l] <span class="op">=</span> w <span class="op">.*</span> <span class="fu">exp</span>.(ηₜ <span class="op">*</span> <span class="fu">view</span>(y, l, <span class="op">:</span>) <span class="op">.-</span> sum1pexpη)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    pθ_given_y <span class="op">=</span> wpy_given_θ <span class="op">./</span> <span class="fu">sum</span>(wpy_given_θ, dims<span class="op">=</span><span class="fl">1</span>)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    (bar_nₖ<span class="op">=</span>pθ_given_y <span class="op">*</span> n,</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        bar_rⱼₖ<span class="op">=</span>pθ_given_y <span class="op">*</span> (n <span class="op">.*</span> y))</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>eloglik_2pl_em (generic function with 1 method)</code></pre>
<div class="sourceCode" id="cb8"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Test:</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>gh15 <span class="op">=</span> <span class="fu">gausshermite</span>(<span class="fl">15</span>)  <span class="co"># 15 quadrature points</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>([-4.499990707309391, -3.669950373404453, -2.9671669279056054, -2.3257324861738606, -1.7199925751864926, -1.136115585210924, -0.5650695832555779, -3.552713678800501e-15, 0.5650695832555779, 1.136115585210924, 1.7199925751864926, 2.3257324861738606, 2.9671669279056054, 3.669950373404453, 4.499990707309391], [1.5224758042535368e-9, 1.0591155477110773e-6, 0.00010000444123250024, 0.0027780688429127607, 0.030780033872546228, 0.15848891579593563, 0.41202868749889865, 0.5641003087264175, 0.41202868749889865, 0.15848891579593563, 0.030780033872546228, 0.0027780688429127607, 0.00010000444123250024, 1.0591155477110773e-6, 1.5224758042535368e-9])</code></pre>
<div class="sourceCode" id="cb10"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>gh15_node <span class="op">=</span> gh15[<span class="fl">1</span>] <span class="op">.*</span> √<span class="fl">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>15-element Vector{Float64}:
 -6.363947888829838
 -5.190093591304782
 -4.196207711269019
 -3.289082424398771
 -2.4324368270097634
 -1.6067100690287344
 -0.7991290683245511
 -5.0242958677880805e-15
  0.7991290683245511
  1.6067100690287344
  2.4324368270097634
  3.289082424398771
  4.196207711269019
  5.190093591304782
  6.363947888829838</code></pre>
<div class="sourceCode" id="cb12"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>gh15_weight <span class="op">=</span> gh15[<span class="fl">2</span>] <span class="op">./</span> √π</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>15-element Vector{Float64}:
 8.589649899633383e-10
 5.975419597920666e-7
 5.642146405189039e-5
 0.0015673575035499477
 0.01736577449213769
 0.08941779539984435
 0.23246229360973225
 0.31825951825951826
 0.23246229360973225
 0.08941779539984435
 0.01736577449213769
 0.0015673575035499477
 5.642146405189039e-5
 5.975419597920666e-7
 8.589649899633383e-10</code></pre>
<div class="sourceCode" id="cb14"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>exp1 <span class="op">=</span> <span class="fu">eloglik_2pl_em</span>(<span class="fu">Matrix</span>(lsat[<span class="op">:</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">5</span>]), lsat[<span class="op">:</span>, <span class="fl">6</span>],</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    gh15_node, gh15_weight,</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    [<span class="fu">ones</span>(<span class="fl">5</span>); <span class="fu">zeros</span>(<span class="fl">5</span>)])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>(bar_nₖ = [2.7564518778742383e-8, 2.0114861555321952e-5, 0.002128243156556154, 0.07560094100777943, 1.3352261691433547, 14.249248990842812, 89.7255889231157, 278.1775106946097, 365.8604302697971, 199.39830527246278, 46.43045474007526, 4.57238810409275, 0.17124982332670236, 0.001845015100526724, 2.6708429185723037e-6], bar_rⱼₖ = [4.138800953383068e-10 4.341143688898378e-11 … 8.455317850390647e-11 2.4966992659649684e-10; 9.488948442862142e-7 1.0961092559330794e-7 … 2.0276924419430197e-7 5.791071220863187e-7; … ; 0.0018436478096575996 0.0018377274514118978 … 0.0018394578991136525 0.0018424609777163434; 2.670229820441103e-6 2.667573675000273e-6 … 2.6683500732256074e-6 2.669698207072498e-6])</code></pre>
<p>The output is a tuple, with the first element <code>bar_nₖ</code> being a <span class="math inline">\(q\)</span> <span class="math inline">\(\times\)</span> 1 vector and <code>bar_rⱼₖ</code> being a <span class="math inline">\(q\)</span> <span class="math inline">\(\times\)</span> <span class="math inline">\(p\)</span> matrix.</p>
</section>
<section id="solve-estimating-equations" class="level3">
<h3 class="anchored" data-anchor-id="solve-estimating-equations">Solve estimating equations</h3>
<div class="sourceCode" id="cb16"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">compute_probs</span>(θ, a, d)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    [<span class="fu">logistic</span>(θ[i] <span class="op">*</span> a[j] <span class="op">+</span> d[j]) for i <span class="op">=</span> <span class="fu">eachindex</span>(θ), j <span class="op">=</span> <span class="fu">eachindex</span>(a)]</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>compute_probs (generic function with 1 method)</code></pre>
<div class="sourceCode" id="cb18"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">esteq_2pl_em</span>(par, bar_r, bar_n, θ)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    num_items <span class="op">=</span> <span class="fu">size</span>(bar_r, <span class="fl">2</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> par[<span class="fl">1</span><span class="op">:</span>num_items]</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> par[num_items<span class="op">+</span><span class="fl">1</span><span class="op">:</span><span class="kw">end</span>]</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    rmntpθ <span class="op">=</span> bar_r <span class="op">.-</span> bar_n <span class="op">.*</span> <span class="fu">compute_probs</span>(θ, a, d)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">vec</span>([<span class="fu">sum</span>(rmntpθ, dims<span class="op">=</span><span class="fl">1</span>) θ<span class="ch">' * rmntpθ])</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>esteq_2pl_em (generic function with 1 method)</code></pre>
<div class="sourceCode" id="cb20"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Test:</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>root1 <span class="op">=</span> <span class="fu">nlsolve</span>(x <span class="op">-&gt;</span> <span class="fu">esteq_2pl_em</span>(x, </span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    exp1.bar_rⱼₖ, exp1.bar_nₖ, gh15_node),</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    [<span class="fu">ones</span>(<span class="fl">5</span>); <span class="fu">zeros</span>(<span class="fl">5</span>)])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Results of Nonlinear Solver Algorithm
 * Algorithm: Trust-region with dogleg and autoscaling
 * Starting Point: [1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0]
 * Zero: [0.9441787368725837, 0.9412834339373086, 0.9702850411757558, 0.932179532744094, 0.9197528908890249, 2.166166737455263, 0.41020205101729856, -0.37879989990817486, 0.7262454452107591, 1.5321165384312954]
 * Inf-norm of residuals: 0.000000
 * Iterations: 6
 * Convergence: true
   * |x - x'| &lt; 0.0e+00: false
   * |f(x)| &lt; 1.0e-08: true
 * Function Calls (f): 7
 * Jacobian Calls (df/dx): 7</code></pre>
<p>The solution is contained in the <code>zero</code> field. These will be passed back to the E-step.</p>
</section>
<section id="iterations" class="level3">
<h3 class="anchored" data-anchor-id="iterations">Iterations</h3>
<p>We can do two more iterations:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>exp2 <span class="op">=</span> <span class="fu">eloglik_2pl_em</span>(<span class="fu">Matrix</span>(lsat[<span class="op">:</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">5</span>]), lsat[<span class="op">:</span>, <span class="fl">6</span>],</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    gh15_node, gh15_weight,</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    root1.zero)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>(bar_nₖ = [1.7202823621463788e-7, 0.00012478229640175463, 0.012917226708649957, 0.42950281900235543, 6.374685649928196, 47.54065170285358, 177.55073039082802, 324.1944490261614, 289.0821550106182, 125.99472138888558, 26.268899898287724, 2.460042585603299, 0.09015529832828216, 0.0009626597451594212, 1.3887248384670485e-6], bar_rⱼₖ = [5.372365387113749e-9 6.042186880320284e-10 … 1.1967481795709406e-9 3.692939772198374e-9; 1.1195428419388414e-5 1.486089377064305e-6 … 2.671355380687325e-6 7.62773320369415e-6; … ; 0.0009620030652981468 0.000959109431245618 … 0.0009598307020344003 0.0009612789437790556; 1.3884114755863066e-6 1.3870244275199353e-6 … 1.3873554006168715e-6 1.3880472692324014e-6])</code></pre>
<div class="sourceCode" id="cb24"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>root2 <span class="op">=</span> <span class="fu">nlsolve</span>(x <span class="op">-&gt;</span> <span class="fu">esteq_2pl_em</span>(x, </span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    exp2.bar_rⱼₖ, exp2.bar_nₖ, gh15_node),</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    root1.zero)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Results of Nonlinear Solver Algorithm
 * Algorithm: Trust-region with dogleg and autoscaling
 * Starting Point: [0.9441787368725837, 0.9412834339373086, 0.9702850411757558, 0.932179532744094, 0.9197528908890249, 2.166166737455263, 0.41020205101729856, -0.37879989990817486, 0.7262454452107591, 1.5321165384312954]
 * Zero: [0.8851376144605885, 0.8780270229700008, 0.9305712408536134, 0.8617362606683743, 0.8410113215381403, 2.5424571803032903, 0.781691569809412, -0.0034125639910551494, 1.0943152659197337, 1.8930834808194317]
 * Inf-norm of residuals: 0.000000
 * Iterations: 4
 * Convergence: true
   * |x - x'| &lt; 0.0e+00: false
   * |f(x)| &lt; 1.0e-08: true
 * Function Calls (f): 5
 * Jacobian Calls (df/dx): 5</code></pre>
<div class="sourceCode" id="cb26"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>exp3 <span class="op">=</span> <span class="fu">eloglik_2pl_em</span>(<span class="fu">Matrix</span>(lsat[<span class="op">:</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">5</span>]), lsat[<span class="op">:</span>, <span class="fl">6</span>],</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    gh15_node, gh15_weight,</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    root2.zero)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>(bar_nₖ = [4.3023109522800455e-7, 0.0003040218519114245, 0.02987372125524563, 0.9055221912858598, 11.602389316066303, 71.03280737295191, 214.59437201659995, 325.67522637877084, 253.23782066569376, 101.01070654940031, 20.01802278052005, 1.826159972919833, 0.06609181187521956, 0.000701760614451534, 1.0099632324488185e-6], bar_rⱼₖ = [2.0531055047839344e-8 2.5014192320684056e-9 … 4.965693882437507e-9 1.5557900531690245e-8; 3.8265586589167865e-5 5.753192037170773e-6 … 1.0076467391887043e-5 2.8241538126234826e-5; … ; 0.0007012180412131716 0.0006987629848589311 … 0.0006992811247620892 0.0007004963056719968; 1.00968636885505e-6 1.0084204735673418e-6 … 1.008662595953656e-6 1.0092845394530493e-6])</code></pre>
<div class="sourceCode" id="cb28"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>root3 <span class="op">=</span> <span class="fu">nlsolve</span>(x <span class="op">-&gt;</span> <span class="fu">esteq_2pl_em</span>(x, </span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    exp3.bar_rⱼₖ, exp3.bar_nₖ, gh15_node),</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    root2.zero)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Results of Nonlinear Solver Algorithm
 * Algorithm: Trust-region with dogleg and autoscaling
 * Starting Point: [0.8851376144605885, 0.8780270229700008, 0.9305712408536134, 0.8617362606683743, 0.8410113215381403, 2.5424571803032903, 0.781691569809412, -0.0034125639910551494, 1.0943152659197337, 1.8930834808194317]
 * Zero: [0.8479491477352421, 0.8323916555812338, 0.902644467313084, 0.8111833641429015, 0.7863596508859064, 2.6865158580988453, 0.9283333274643143, 0.1559502636058875, 1.2352944393730914, 2.0242412851515406]
 * Inf-norm of residuals: 0.000000
 * Iterations: 4
 * Convergence: true
   * |x - x'| &lt; 0.0e+00: false
   * |f(x)| &lt; 1.0e-08: true
 * Function Calls (f): 5
 * Jacobian Calls (df/dx): 5</code></pre>
</section>
<section id="stopping-criteria" class="level3">
<h3 class="anchored" data-anchor-id="stopping-criteria">Stopping criteria</h3>
<p>One way to stop the iteration is when the absolute change in the parameter estimates is less than a certain threshold (e.g., 0.00001). For example, the following shows the maximum absolute change in the parameter estimates from the second and the third iteration:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="fu">maximum</span>(<span class="fu">abs</span>.(root3.zero <span class="op">.-</span> root2.zero))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>0.15936282759694267</code></pre>
<p>which is pretty large. So we should do more iterations.</p>
</section>
</section>
<section id="benchmarking" class="level2">
<h2 class="anchored" data-anchor-id="benchmarking">Benchmarking</h2>
<p>We can wrap the steps into a function</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">estimate_2pl_em</span>(y, n, init, </span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    n_quadpts<span class="op">=</span><span class="fl">101</span>, par_tol<span class="op">=</span><span class="fl">1e-5</span>, rtol<span class="op">=</span><span class="fl">1e-5</span>, max_iter<span class="op">=</span><span class="fl">1000</span>)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    parₜ <span class="op">=</span> init</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    parₜ₊₁ <span class="op">=</span> parₜ</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert y to matrix</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> <span class="fu">Matrix</span>(y)</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Obtain quadrature nodes and weights</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    ghq <span class="op">=</span> <span class="fu">gausshermite</span>(n_quadpts)</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    ghq_θ <span class="op">=</span> ghq[<span class="fl">1</span>] <span class="op">.*</span> √<span class="fl">2</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    ghq_w <span class="op">=</span> ghq[<span class="fl">2</span>] <span class="op">./</span> √π</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="fl">1</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;</span> max_iter</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>        expₜ <span class="op">=</span> <span class="fu">eloglik_2pl_em</span>(y, n,</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>    ghq_θ, ghq_w, parₜ)</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>        root <span class="op">=</span> <span class="fu">nlsolve</span>(x <span class="op">-&gt;</span> <span class="fu">esteq_2pl_em</span>(x, </span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>    expₜ.bar_rⱼₖ, expₜ.bar_nₖ, ghq_θ),</span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>            parₜ, autodiff<span class="op">=:</span>forward)</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>        parₜ₊₁ <span class="op">=</span> root.zero</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="fu">maximum</span>(<span class="fu">abs</span>.(parₜ₊₁ <span class="op">-</span> parₜ)) <span class="op">&lt;</span> par_tol</span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>            parₜ <span class="op">=</span> parₜ₊₁</span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="fl">1</span></span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>    (estimate<span class="op">=</span>parₜ₊₁, num_iter<span class="op">=</span>i)</span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>estimate_2pl_em (generic function with 5 methods)</code></pre>
<div class="sourceCode" id="cb34"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> est_em <span class="op">=</span> <span class="fu">estimate_2pl_em</span>(lsat[<span class="op">:</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">5</span>], lsat[<span class="op">:</span>, <span class="fl">6</span>], [<span class="fu">ones</span>(<span class="fl">5</span>); <span class="fu">zeros</span>(<span class="fl">5</span>)])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>  16.968 ms (16212 allocations: 29.76 MiB)

(estimate = [0.8256464036061023, 0.7227767138869371, 0.8907854481666115, 0.6883896452213724, 0.6568975184341934, 2.773226187628446, 0.9902095352382095, 0.24914112339506816, 1.284763785097769, 2.0532889359951128], num_iter = 66)</code></pre>
<p>Compare to <code>mirt</code></p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"LSAT"</span>, <span class="at">package =</span> <span class="st">"ltm"</span>)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mirt)</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>bench<span class="sc">::</span><span class="fu">mark</span>(</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">mirt =</span> <span class="fu">mirt</span>(LSAT,</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>                <span class="at">verbose =</span> <span class="cn">FALSE</span>, <span class="at">quadpts =</span> <span class="dv">101</span>,</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>                <span class="at">TOL =</span> <span class="fl">1e-5</span>)</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code># A tibble: 1 × 6
  expression      min   median `itr/sec` mem_alloc `gc/sec`
  &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;
1 mirt          107ms    107ms      9.38    22.4MB     28.1</code></pre>
</section>
<section id="remark" class="level2">
<h2 class="anchored" data-anchor-id="remark">Remark</h2>
<p>My implementation of the EM takes a shorter time to run than direct MML (see my post in <a href="../../2022/05/19/estimating-a-2-pl-model-in-julia-part-1/">Part 1</a>), but it does not compute the standard errors. Also, it probably uses a different convergence criterion than direct MML using <code>Optim.jl</code>, so it’s hard to say which one is faster.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">Copyright 2023, Hok Chio (Mark) Lai</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>



</body></html>